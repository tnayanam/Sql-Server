So We need a SQL Server installed in the system. Once that is installed we need a GUI (SSMS) to interact with it. So we need to install that too. So firstly we need to connect to the SQL Server Engine
 via SSMS. 
		Provide Server Type: Database Engine.
        Server Name: It should be the Name or IP Address of that server.
		Authentication: Here we can give an authentication to connect. if we give "windows authentication" then we dont need to do anything because we are already logged into the windows. (Best)
		If we give SQL Server authentication then while installin the Sql Server we must have given one user and password that we need to use.
		               
					
Create Database Manually
CMD: Create Database SampleDB

Location of Database file. Click on the Database to which you want to explore and right click property and then go to Files and there you will find Path Tab.

Change the Name of the Database
CMD: Alter Database Sample2 Modify Name = Sample3

Rename Database using System Defined SProc
CMD: sp_renameDB 'Sample3', 'Sample4'

Drop a Database
CMD: Drop Database Sample4;    

Create a Table from GUI in SSMS:
Once you give all the table column details you can click on top of the tab related to that table column and click on Save.
Before running any query make sure that in top dropdown correct Database is selected.

Create a Table
CMD: 
Create Table tblGender
(
ID  int NOT NULL Primary Key,
Gender nvarchar(50) NOT NULL
)

Create table to a particular Database via Command

CMD: 
Use Sample1
Create Table tblGender
(
ID  int NOT NULL Primary Key,
Gender nvarchar(50) NOT NULL
)

Foreign Key Constraint
CMD: Alter Table tblPerson add Constraint tblPerson_GenderID_FK 
Foreign Key (GenderId) references tblGender(ID);

Default Value in table column
CMD: Alter Table tblPerson Add Constraint DF_tblPerson_genderIdl
DEFAULT 3 FOR GenderId

Insert When not all columns are included
CMD: Insert INTO tblPerson (ID, Name, Email) values (5, 'Jonny', 'j@J.com')

Insert when all columns are included we dnt need to mentioned column name
CMD: Insert INTO tblPerson VALUES (6, 'Arun', 'a@a.com', 2)

Drop a constraint
CMD: ALTER TABLE tblPerson Drop Constraint DF_tblPerson_genderId

Cascading Referential Integrity

1. Drop the corresponding child table when primary table is deleted:

CMD: Alter table tblPerson Add Constraint tblPerson_GenderID_FK  Foreign key (GenderId) References tblGender(ID) on delete cascade;
On Delete cascade if you forgot to add while making the initial Foreign key Relationship then you need to drop the FK constraint and then readd the FK constraint like above. 

2. Set the corresponding Foreign key to NULL value and keep rest of the row value intact
CMD: Alter table tblPerson Add Constraint tblPerson_GenderID_FK  Foreign key (GenderId) References tblGender(ID) on delete set NULL;

3. If we want to set some default value then first give  a default value to the parent table and then use below command
CMD: Alter table tblPerson Add Constraint tblPerson_GenderID_FK  Foreign key (GenderId) References tblGender(ID) on delete set DEFAULT;

Add a Column
CMD: Alter table tblPerson add Age integer


Add Constraint at the Database level for disallowing certain values
CMD: Alter table tblPerson Add Constraint CK_tblPerson_Age CHECK (AGE > 0 AND AGE < 150);

For adding Identity value manually and not by DB Automatically
CMD: Set Identity_Insert TableName ON

If we want DB to automatically insert the Identity Column Value
CMD: Set Identity_Insert TableName OFF

Reseed the value of identity column to 1
CMD: DBCC CheckIdent(tblPersonOne, Reseed,0)

Add an Identity column
CMD: Create table Test2
(
	ID int Identity (1,1),
	Value nvarchar(20)
)

How to get the last identity column
CMD: Select SCOPE_IDENTITY();  => returns same session value => Most commonly used.
CMD: Select @@Identity ; => returns same session across any scope so, if any trigger is there and it is updating that table it wil give the identity of that table.

CMD: select ident_current('test1');   => Important, across any session

Primary key and Unique Key:
primary Key cannot be NULL but Unique key can be NULL

Add Unique Key Constraint
CMD: Alter table tblPerson Add constraint UQ_tblPerson_Email Unique(Email);

Get Distinct row values in a column
CMD: Select DISTINCT columnName from TableName

Filter values in rows
CMD: Select columnName from tblPersonOne where pid = 2;

Not equal to:
CMD: Select columnName from tblPersonOne WHERE pid <> 2;

Put a list in where clause
CMD: select * from tblPerson where GenderId IN (1,3);

Between a range
CMD: select * from tblPerson where GenderId BETWEEN 2 and 3; 2 and 3 are inclusive

LIKE
CMD: select * from tblPerson where name like '%M%';

NOT
CMD: select * from tblPerson where name NOT LIKE '%M%';

Multiple condition in WHERE
CMD: 
select * from tblPerson where ( city = 'Mumbai' or city = 'Delhi') and Age > 20;

SORT
CMD: Select * from tblPerson order by name desc;

Mulitple column SORT
CMD: Select * from tblPerson order by name desc,city asc;

Top Records:
CMD: select  top 3 Name from tblPerson;

Top Records:
CMD: select  top 2 * from tblPerson;

TOP first record
CMD: select top 1 * from tblPerson order by age desc;

Aggregate Function and GROUP  BY - Group by clause is always used in 
CMD:select  age, count(*) from tblPerson group by age;

Max
CMD: select MAX(age) from tblPerson;

MIN
CMD:select MIN(age) from tblPerson;

City wise salary, GROUP BY
select SUM(salary), city from tblPerson GROUP BY city; 

Alias to aggregate functions
CMD: select sum(salary) as TotalSalary, city from tblPerson group by city; 
Output:
58584	Bombay
80733	Delhi
65659	Gujrat
28365	Mumbai

Multiple group By
CMD: select sum(salary) as TotalSalary, city,GenderId from tblPerson group by city,GenderId;
Output:
25845	Delhi	NULL
58584	Bombay	1
28365	Mumbai	1
54888	Delhi	2
65659	Gujrat	3

Point: Clearly the city is again broken into gender wise. Nice!!!!

Use Space in Column name when Aliasing
CMD: select city, sum(salary) as [Total Salary], GenderId, count(ID) from tblPerson group by GenderId, city;

Filter the output using Having and Where in GroupBy also square bracket gives space b/w alases

CMD: select city, sum(salary) as [Total Salary], GenderId, count(ID) from tblPerson group by GenderId, city having GenderId = 1;

CMD: select city, sum(salary) as [Total Salary], GenderId, count(ID) from tblPerson where GenderId = 1 group by GenderId, city ;


Difference between having and where clause
WHERE clause filters the result before and then aggregates them as per the group by clause
HAVING aggregates all the stuff and then applies filter to it.

Aggregate function can be used in having clause but cannot be used in where clause
Where SUM(Salary) > 1000;   === Wrong
HAVING SUM(Salary) >  1000; === Correct

Joins

Inner Join:

CMD: select e.name, e.gender, d.DepartmentName from tblEmployee as e INNER JOIN tblDepartment as d on e.DeptId = d.Id; 

CMD: select name, gender, DepartmentName from tblEmployee as e INNER JOIN tblDepartment as d on e.DeptId = d.Id; 

Left Outer Join:

CMD: select name, gender, DepartmentName from tblEmployee as e LEFT OUTER JOIN tblDepartment as d on e.DeptId = d.Id; 

Right Outer Join

CMD: select name, gender, DepartmentName from tblEmployee as e Right OUTER JOIN tblDepartment as d on e.DeptId = d.Id; 

Full Outer Join

CMD: select name, gender, DepartmentName from tblEmployee as e full outer join  tblDepartment as d on e.DeptId = d.Id;

Cross Join:

CMD: select name, gender, DepartmentName from tblEmployee as e Cross JOIN tblDepartment as d;

NonMatching rows from left table
CMD: select name, gender, DepartmentName from tblEmployee as e LEFT OUTER JOIN tblDepartment as d on e.DeptId = d.Id where e.DeptId IS NULL; 

NonMatching rows form the right table
CMD: select e.DeptId, e.name, e.gender, d.DepartmentName from tblEmployee as e right join tblDepartment as d on e.DeptId = d.Id where e.DeptId IS NULL; 

NonMatching from both the tables

CMD: select e.DeptId, e.name, e.gender, d.DepartmentName from tblEmployee as e full join tblDepartment as d on e.DeptId = d.Id where e.DeptId IS NULL or d.Id IS NULL; 

SELF Join is same as above joins
CMD: select e.EmployeeID, e.Name, m.ManagerID, m.Name from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID;
 -- Try to imagine if they are two different tables and then apply normal joining procedures.
 
ISNULL
CMD: select e.EmployeeID, e.Name, m.ManagerID, ISNULL(m.Name, 'No Manager') from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID; -- left outer self join
Now NUll value will be replaced.

Coalesce:
CMD:   select e.EmployeeID, e.Name, m.ManagerID, COALESCE(m.Name, 'No Manager') from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID; -- left outer self join

CASE
CMD:   select e.EmployeeID, e.Name, m.ManagerID,   CASE WHEN m.Name IS NULL THEN 'No Manager' ELSE '' END from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID; -- left outer self join;

Coalesce returns first NOT NULL values
Tanuj     	Nayanam   
Rajesh    	Kulkarni  
Jupiter   	Mars      
Mercury   	NULL    
NULL	   April    => here it should return April 

CMD:  Select coalesce(FName, LName) from tblEmp;

UNION and UNION ALL

Both works when column name are same and count.
But Union all will show even the duplicate rows but union will allow dupe rows to come once.
tblOne
1	Rajesh    
2	Nayanam   

tblTwo
1	Tanuj     
2	Nayanam   

CMD: Select * from tblOne union all Select * from tblTwo; Output
  
1	Rajesh    
2	Nayanam   
1	Tanuj     
2	Nayanam   

CMD:   Select * from tblOne  union   Select * from tblTwo;

1	Rajesh    
1	Tanuj     
2	Nayanam   

Difference between Union and Join:

Union combines table from two or more rows Join combines table from two or more column based on some PK FK Relationships

Stored Procedures:

When we need to repeat same SQL command over and over again then better to write a stored procedure.

CMD:  Create procedure spGetEmployees
  AS
  BEGIN
    select name, gender from tblEmployee
  END
  
Calling a Sproc
CMD: spGetEmployees;
CMD: EXECUTE spGetEmployees;


Sproc with parameter
CMD:   create proc spGetEmpByGenderAndDepartment
@Gender nvarchar(50),
@DeptId int
AS
Begin
Select Name,Gender,DeptId from tblEmployee Where Gender = @Gender and DeptId = @DeptId
End

Execution:
CMD:   spGetEmpByGenderAndDepartment 'male', 1

View the definition of Stored Procedure:

CMD:   sp_helptext spGetEmpByGenderAndDepartment

Alter a Stored Procedure:

CMD:Alter proc spGetEmpByGenderAndDepartment
@Gender nvarchar(50),
@DeptId int
AS
Begin
Select Name,Gender,DeptId from tblEmployee Where Gender = @Gender and DeptId = @DeptId order by Name desc
End

Delete a Stored Procedure
CMD: Drop proc spGetEmpByGenderAndDepartment

Encrypt the Stored Procedure 

CMD: 

   Alter proc spGetEmpByGenderAndDepartment
  @Gender nvarchar(50),
  @DeptId int WITH ENCRYpTION
  AS
  Begin
  Select Name,Gender,DeptId from tblEmployee Where Gender = @Gender and DeptId = @DeptId order by Name desc
  End

  
 SProc with output parameters: 
 
 CMD: CREATION:   create proc spGetEmpCountByGender
  @Gender nvarchar(20),
  @EmployeeCount int output
  as
  BEGIN
  Select  @EmployeeCount = count(Id) from tblEmployee where gender = @Gender
  END

 EXECUTION:  Declare  @TotalCount int
  Execute   spGetEmpCountByGender 'Male', @TotalCount out
  Print @TotalCount

  Information about a Stored Procedure
CMD:   sp_help spGetEmpCountByGender;


