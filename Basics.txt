So We need a SQL Server installed in the system. Once that is installed we need a GUI (SSMS) to interact with it. So we need to install that too. So firstly we need to connect to the SQL Server Engine
 via SSMS. 
		Provide Server Type: Database Engine.
        Server Name: It should be the Name or IP Address of that server.
		Authentication: Here we can give an authentication to connect. if we give "windows authentication" then we dont need to do anything because we are already logged into the windows. (Best)
		If we give SQL Server authentication then while installin the Sql Server we must have given one user and password that we need to use.
		               
					
Create Database Manually
CMD: Create Database SampleDB

Location of Database file. Click on the Database to which you want to explore and right click property and then go to Files and there you will find Path Tab.

Change the Name of the Database
CMD: Alter Database Sample2 Modify Name = Sample3

Rename Database using System Defined SProc
CMD: sp_renameDB 'Sample3', 'Sample4'

Drop a Database
CMD: Drop Database Sample4;    

Create a Table from GUI in SSMS:
Once you give all the table column details you can click on top of the tab related to that table column and click on Save.
Before running any query make sure that in top dropdown correct Database is selected.

Create a Table
CMD: 
Create Table tblGender
(
ID  int NOT NULL Primary Key,
Gender nvarchar(50) NOT NULL
)

Create table to a particular Database via Command

CMD: 
Use Sample1
Create Table tblGender
(
ID  int NOT NULL Primary Key,
Gender nvarchar(50) NOT NULL
)

Foreign Key Constraint
CMD: Alter Table tblPerson add Constraint tblPerson_GenderID_FK 
Foreign Key (GenderId) references tblGender(ID);

Default Value in table column
CMD: Alter Table tblPerson Add Constraint DF_tblPerson_genderIdl
DEFAULT 3 FOR GenderId

Insert When not all columns are included
CMD: Insert INTO tblPerson (ID, Name, Email) values (5, 'Jonny', 'j@J.com')

Insert when all columns are included we dnt need to mentioned column name
CMD: Insert INTO tblPerson VALUES (6, 'Arun', 'a@a.com', 2)

Drop a constraint
CMD: ALTER TABLE tblPerson Drop Constraint DF_tblPerson_genderId

Cascading Referential Integrity

1. Drop the corresponding child table when primary table is deleted:

CMD: Alter table tblPerson Add Constraint tblPerson_GenderID_FK  Foreign key (GenderId) References tblGender(ID) on delete cascade;
On Delete cascade if you forgot to add while making the initial Foreign key Relationship then you need to drop the FK constraint and then readd the FK constraint like above. 

2. Set the corresponding Foreign key to NULL value and keep rest of the row value intact
CMD: Alter table tblPerson Add Constraint tblPerson_GenderID_FK  Foreign key (GenderId) References tblGender(ID) on delete set NULL;

3. If we want to set some default value then first give  a default value to the parent table and then use below command
CMD: Alter table tblPerson Add Constraint tblPerson_GenderID_FK  Foreign key (GenderId) References tblGender(ID) on delete set DEFAULT;

Add a Column
CMD: Alter table tblPerson add Age integer


Add Constraint at the Database level for disallowing certain values
CMD: Alter table tblPerson Add Constraint CK_tblPerson_Age CHECK (AGE > 0 AND AGE < 150);

For adding Identity value manually and not by DB Automatically
CMD: Set Identity_Insert TableName ON

If we want DB to automatically insert the Identity Column Value
CMD: Set Identity_Insert TableName OFF

Reseed the value of identity column to 1
CMD: DBCC CheckIdent(tblPersonOne, Reseed,0)

Add an Identity column
CMD: Create table Test2
(
	ID int Identity (1,1),
	Value nvarchar(20)
)

How to get the last identity column
CMD: Select SCOPE_IDENTITY();  => returns same session value => Most commonly used.
CMD: Select @@Identity ; => returns same session across any scope so, if any trigger is there and it is updating that table it wil give the identity of that table.

CMD: select ident_current('test1');   => Important, across any session

Primary key and Unique Key:
primary Key cannot be NULL but Unique key can be NULL

Add Unique Key Constraint
CMD: Alter table tblPerson Add constraint UQ_tblPerson_Email Unique(Email);

Get Distinct row values in a column
CMD: Select DISTINCT columnName from TableName

Filter values in rows
CMD: Select columnName from tblPersonOne where pid = 2;

Not equal to:
CMD: Select columnName from tblPersonOne WHERE pid <> 2;

Put a list in where clause
CMD: select * from tblPerson where GenderId IN (1,3);

Between a range
CMD: select * from tblPerson where GenderId BETWEEN 2 and 3; 2 and 3 are inclusive

LIKE
CMD: select * from tblPerson where name like '%M%';

NOT
CMD: select * from tblPerson where name NOT LIKE '%M%';

Multiple condition in WHERE
CMD: 
select * from tblPerson where ( city = 'Mumbai' or city = 'Delhi') and Age > 20;

SORT
CMD: Select * from tblPerson order by name desc;

Mulitple column SORT
CMD: Select * from tblPerson order by name desc,city asc;

Top Records:
CMD: select  top 3 Name from tblPerson;

Top Records:
CMD: select  top 2 * from tblPerson;

TOP first record
CMD: select top 1 * from tblPerson order by age desc;

Aggregate Function and GROUP  BY - Group by clause is always used in 
CMD:select  age, count(*) from tblPerson group by age;

Max
CMD: select MAX(age) from tblPerson;

MIN
CMD:select MIN(age) from tblPerson;

City wise salary, GROUP BY
select SUM(salary), city from tblPerson GROUP BY city; 

Alias to aggregate functions
CMD: select sum(salary) as TotalSalary, city from tblPerson group by city; 
Output:
58584	Bombay
80733	Delhi
65659	Gujrat
28365	Mumbai

Multiple group By
CMD: select sum(salary) as TotalSalary, city,GenderId from tblPerson group by city,GenderId;
Output:
25845	Delhi	NULL
58584	Bombay	1
28365	Mumbai	1
54888	Delhi	2
65659	Gujrat	3

Point: Clearly the city is again broken into gender wise. Nice!!!!

Use Space in Column name when Aliasing
CMD: select city, sum(salary) as [Total Salary], GenderId, count(ID) from tblPerson group by GenderId, city;

Filter the output using Having and Where in GroupBy also square bracket gives space b/w alases

CMD: select city, sum(salary) as [Total Salary], GenderId, count(ID) from tblPerson group by GenderId, city having GenderId = 1;

CMD: select city, sum(salary) as [Total Salary], GenderId, count(ID) from tblPerson where GenderId = 1 group by GenderId, city ;


Difference between having and where clause
WHERE clause filters the result before and then aggregates them as per the group by clause
HAVING aggregates all the stuff and then applies filter to it.

Aggregate function can be used in having clause but cannot be used in where clause
Where SUM(Salary) > 1000;   === Wrong
HAVING SUM(Salary) >  1000; === Correct

Joins

Inner Join:

CMD: select e.name, e.gender, d.DepartmentName from tblEmployee as e INNER JOIN tblDepartment as d on e.DeptId = d.Id; 

CMD: select name, gender, DepartmentName from tblEmployee as e INNER JOIN tblDepartment as d on e.DeptId = d.Id; 

Left Outer Join:

CMD: select name, gender, DepartmentName from tblEmployee as e LEFT OUTER JOIN tblDepartment as d on e.DeptId = d.Id; 

Right Outer Join

CMD: select name, gender, DepartmentName from tblEmployee as e Right OUTER JOIN tblDepartment as d on e.DeptId = d.Id; 

Full Outer Join

CMD: select name, gender, DepartmentName from tblEmployee as e full outer join  tblDepartment as d on e.DeptId = d.Id;

Cross Join:

CMD: select name, gender, DepartmentName from tblEmployee as e Cross JOIN tblDepartment as d;

NonMatching rows from left table
CMD: select name, gender, DepartmentName from tblEmployee as e LEFT OUTER JOIN tblDepartment as d on e.DeptId = d.Id where e.DeptId IS NULL; 

NonMatching rows form the right table
CMD: select e.DeptId, e.name, e.gender, d.DepartmentName from tblEmployee as e right join tblDepartment as d on e.DeptId = d.Id where e.DeptId IS NULL; 

NonMatching from both the tables

CMD: select e.DeptId, e.name, e.gender, d.DepartmentName from tblEmployee as e full join tblDepartment as d on e.DeptId = d.Id where e.DeptId IS NULL or d.Id IS NULL; 

SELF Join is same as above joins
CMD: select e.EmployeeID, e.Name, m.ManagerID, m.Name from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID;
 -- Try to imagine if they are two different tables and then apply normal joining procedures.
 
ISNULL
CMD: select e.EmployeeID, e.Name, m.ManagerID, ISNULL(m.Name, 'No Manager') from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID; -- left outer self join
Now NUll value will be replaced.

Coalesce:
CMD:   select e.EmployeeID, e.Name, m.ManagerID, COALESCE(m.Name, 'No Manager') from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID; -- left outer self join

CASE
CMD:   select e.EmployeeID, e.Name, m.ManagerID,   CASE WHEN m.Name IS NULL THEN 'No Manager' ELSE '' END from tblEmp e left join tblEmp m on e.ManagerID = m.EmployeeID; -- left outer self join;

Coalesce returns first NOT NULL values
Tanuj     	Nayanam   
Rajesh    	Kulkarni  
Jupiter   	Mars      
Mercury   	NULL    
NULL	   April    => here it should return April 

CMD:  Select coalesce(FName, LName) from tblEmp;

UNION and UNION ALL

Both works when column name are same and count.
But Union all will show even the duplicate rows but union will allow dupe rows to come once.
tblOne
1	Rajesh    
2	Nayanam   

tblTwo
1	Tanuj     
2	Nayanam   

CMD: Select * from tblOne union all Select * from tblTwo; Output
  
1	Rajesh    
2	Nayanam   
1	Tanuj     
2	Nayanam   

CMD:   Select * from tblOne  union   Select * from tblTwo;

1	Rajesh    
1	Tanuj     
2	Nayanam   

Difference between Union and Join:

Union combines table from two or more rows Join combines table from two or more column based on some PK FK Relationships

Stored Procedures:

When we need to repeat same SQL command over and over again then better to write a stored procedure.

CMD:  Create procedure spGetEmployees
  AS
  BEGIN
    select name, gender from tblEmployee
  END
  
Calling a Sproc
CMD: spGetEmployees;
CMD: EXECUTE spGetEmployees;


Sproc with parameter
CMD:   create proc spGetEmpByGenderAndDepartment
@Gender nvarchar(50),
@DeptId int
AS
Begin
Select Name,Gender,DeptId from tblEmployee Where Gender = @Gender and DeptId = @DeptId
End

Execution:
CMD:   spGetEmpByGenderAndDepartment 'male', 1

View the definition of Stored Procedure:

CMD:   sp_helptext spGetEmpByGenderAndDepartment

Alter a Stored Procedure:

CMD:Alter proc spGetEmpByGenderAndDepartment
@Gender nvarchar(50),
@DeptId int
AS
Begin
Select Name,Gender,DeptId from tblEmployee Where Gender = @Gender and DeptId = @DeptId order by Name desc
End

Delete a Stored Procedure
CMD: Drop proc spGetEmpByGenderAndDepartment

Encrypt the Stored Procedure 

CMD: 

   Alter proc spGetEmpByGenderAndDepartment
  @Gender nvarchar(50),
  @DeptId int WITH ENCRYpTION
  AS
  Begin
  Select Name,Gender,DeptId from tblEmployee Where Gender = @Gender and DeptId = @DeptId order by Name desc
  End

  
 SProc with output parameters: 
 
 CMD: CREATION:   create proc spGetEmpCountByGender
  @Gender nvarchar(20),
  @EmployeeCount int output
  as
  BEGIN
  Select  @EmployeeCount = count(Id) from tblEmployee where gender = @Gender
  END

 EXECUTION:  Declare  @TotalCount int
  Execute   spGetEmpCountByGender 'Male', @TotalCount out
  Print @TotalCount

  Information about a Stored Procedure
CMD:   sp_help spGetEmpCountByGender;

Sproc using output parameter and Return Values

CMD:
  Create proc spGetTotalCountOne
  @TotalCount int Out
  as Begin
  Select @TotalCount = COUNT(Id) from tblEmployee;
  end


  Declare @TotalCount int
  Execute spGetTotalCountOne @TotalCount out
  print @TotalCount


 CREATE proc spGetTotalCountTwo
  as 
  Begin
  Return(Select COUNT(Id) from tblEmployee)
  end

    Declare @TotalCount int
	execute    @TotalCount =  spGetTotalCountTwo
	print @TotalCount
	
	Sproc with one input and one output variable
	
	CMD:  	CREATE PROC spGetNameByIdOne
	@Id int,
	@Name nvarchar(50) OUT
	AS
	Begin
	select @Name = Name from tblEmployee where Id = @Id
	End

	Declare @EmpName nvarchar(50)
	Execute spGetNameByIdOne 2, @EmpName out
	print @EmpName
	
	IMP: Return keyword will not work in below case
			CREATE PROC spGetNameByIdTwo
	@Id int
	AS
	Begin
	Return(select Name from tblEmployee where Id = @Id)
	End

	Declare @EmpName nvarchar(50)
	Execute @EmpName = spGetNameByIdTwo 2
	print @EmpName
	
	Above will throw error because a Sproc can only return an integer value that too only one value, so one needs to use OUT parameter instead of RETURN 
	
	Error: Exception:
	For SQL Server and SSMS to work properly obviously we need the SQL Server to be up and running. More like for our website to run we need IIS Server. So if you get below exception
	
	A network related or instance-specific error occurred while establishing a connection to SQL Server.
	
	Benefit of Stored Procedure:
	
	- Reuse of the same Execution Plan. Caching. Any change made in ad-hoc query creates a new execution plan however not the case with StoredProcedure.
	- Reduce Network Traffic. We just need to specify the procedure name and the paramemter from our code. if we do not have the sProc then in that case we need to provide/transfer the entire
	query over the network.
	- Code Reusability/Maintainability Multiple application can use it.
	- Avoids SQL Injection Attacks.
	
	Time - gives System datetime
    CMD: select GETDATE()
	
	CMD: create table tblDate (c_time time,	c_date date, c_small smalldatetime, c_datetime datetime, c_datetime2 datetime2, c_datetimeoffset datetimeoffset);
	
	CMD: insert into tblDate VALUES (GETDATE(),GETDATE(),GETDATE(),GETDATE(),GETDATE(),GETDATE())
	
	OUTPUT: 09:57:06.0833333	2018-01-09	2018-01-09 09:57:00	2018-01-09 09:57:06.083	2018-01-09 09:57:06.0833333	2018-01-09 09:57:06.0833333 +00:00
	
	IsDate checks whether the input is in correct date format if not it returns 0 otherwise 1.
    CMD: Select IsDate('09:57:06'); -- returns 1
	CMD: Select DAY(GetDate()); -- 9
	CMD:Select MONTH(GetDate()); -- 1
	CMD:Select YEAR(GetDate()); -- 2018
	CMD:select datename(WEEKDAY, GETDATE());  -- Tuesday (string)
	CMD:select datename(MONTH, GETDATE());   --  January (string)
	CMD:select datename(YEAR,GETDATE()); --  2018 (string)
	
	Example:
	CREATE table temp (id int, Name nvarchar(50), dte datetime)

	insert into temp values(1, 'SAM', '1980-12-30 00:00:00:000');
	insert into temp values(2, 'PAM', '1982-09-22 00:00:00:000');
	insert into temp values(3, 'John', '1985-08-22 00:00:00:000');
	insert into temp values(4, 'Sara', '1979-11-29 00:00:00:000');
	
	
	SELECT *, datename(WEEKDAY, dte) as day, Month(dte) as MonthNumber , datename(Month, dte) as MonthName, datename(Year, dte) as YEAR from temp;
	
	1	SAM	1980-12-30 00:00:00.000	Tuesday	12	December	1980
	2	PAM	1982-09-22 00:00:00.000	Wednesday	9	September	1982
	3	John	1985-08-22 00:00:00.000	Thursday	8	August	1985
	4	Sara	1979-11-29 00:00:00.000	Thursday	11	November	1979
	
	select *, datename(WEEKDAY, dte) as day, Month(dte) as [Month Number] , datename(Month, dte) as [Month Name], datename(Year, dte) as YEAR from temp;
	
	Difference between datename and datepart is datepart returns integer where as datename returns string. 
	
	SELECT *, datename(WEEKDAY, dte) as day, Month(dte) as [Month Number] , datename(Month, dte) as [Month Name], datename(Year, dte) as YEAR from temp;
	
	1	SAM	1980-12-30 00:00:00.000	Tuesday	12	December	1980
	2	PAM	1982-09-22 00:00:00.000	Wednesday	9	September	1982
	3	John	1985-08-22 00:00:00.000	Thursday	8	August	1985
	4	Sara	1979-11-29 00:00:00.000	Thursday	11	November	1979

	SELECT *, datepart(WEEKDAY, dte) as day, Month(dte) as [Month Number] , datepart(Month, dte) as [Month Name], datepart(Year, dte) as YEAR from temp;

	1	SAM	1980-12-30 00:00:00.000	3	12	12	1980
	2	PAM	1982-09-22 00:00:00.000	4	9	9	1982
	3	John	1985-08-22 00:00:00.000	5	8	8	1985
	4	Sara	1979-11-29 00:00:00.000	5	11	11	1979
	
	Adds to the date:
	CMD: select DATEADD(DAY, 12, getdate()); --args(which part you want to add, ow much you want tto add, to whic date you want to add)
	
	select datediff(MONTH, getdate(),'2018-5-30'); --args(which part you want to fetch the difference, dtate1, date2)
	
-- Mathematical Functions:
Rand() It returns random number between 0 to 1. Now if we want some number b/w a specified limit then multiply the output. see below
CMd:   select floor(rand()*100)

- above will return just one value, if we want multiple values then we can try below FUNCTION
CMD:   Declare @Counter INT
  Set @Counter = 1
  While(@Counter <=10)
  Begin
  Print  floor(rand()*1000)
 Set @Counter = @Counter + 1
  End
-----------Functions-------------  
  There are 3 types of User Defined Functions
a. Scalar
b. Inline table-valued functions
c. Multi-Statement table-valued functions

A. Scalar Functions

	CMD: Create Function CalculateAgeNew1 (@Dob Int)
	  Returns INT
	  As
	  Begin
	  Declare @test int
	  Set @test = 3
	  Set @Dob = 6 * @test
	  Return @Dob
	  End
		// this will give error
			Select CalculateAgeNew1(10)
		  // this will work as dbo is added
	CMD: Invoke ----	  Select dbo.CalculateAgeNew1(10) As ClmnName

SELECT Clause Function Usage: CALL Function Inline
	CMD: Select Name, DateOfBirth, Salary, dbo.CalculateAgeNew1(Salary) As ClmnName from tblEmployee;
WHERE Clause Function Usage: CALL Function Inline
	CMD: Select Name, DateOfBirth, Salary  from tblEmployee Where dbo.CalculateAgeNew1(Salary) > 1000;
View the text / definition of a function:
    CMD:  sp_helptext CalculateAgeNew1
	
	We cannot use Stored Proc in select and where clause but we can use a function
	
	Inline table valued function:
	
	  CMD: Create Function FilterGender(@Gender nvarchar(10))
			Returns table
			as
			return (select * from tblDepartment where abc = @Gender)

  CALLING:
		CMD:select * from FilterGender('ma')
  CALLING with Where
		CMD:select * from FilterGender('ma') where name = 'test'
		
	Deterministic and Non Deterministic Functions
	A deterministic function always returns same result anytime they are called with a specific set of input values and given the same state of database.
	example - Square, Power, Sum, Average
	A non deterministic function always returns different set of results for same specific set of inputs
	example - GetDate
	
	Basic Function
	CMD:
	Create Function fnFilterGender(@Id int)
		 Returns nvarchar(50)
			as
			begin
			return (select name from tblEmployee where Id = @Id)
			end
	Execution:
	CMD: select dbo.fnFilterGender(1)
	
	View Function Definition:
	CMD: sp_helptext fnFilterGender;
	
	Encryption:
	CMD:
	alter Function fnFilterGender(@Id int)
		 Returns nvarchar(50)
		WITH ENCRYPTION
			as
			begin
			return (select name from tblEmployee where Id = @Id)
			end
			
Schema Binding:
Suppose we have a function that is getting referenced in a function definition and now someone deletes that function so in this case if someone calls that function it willl throw the exception
so we need to somehow do not allow the table to be deleted as long as it is being referenced by any function. 


			alter Function fnFilterGender(@Id int)
		 Returns nvarchar(50)
		 with SCHEMABINDING
			as
			begin
			return (select name from dbo.tblEmployee where Id = @Id)
			end

			Now tblEmployee cannot be deleted. first this fucntion needs to be deleted then only tblEmployee can be deleted.
			
Temporary Tables:
Temporary tables are very much similar to the permanent tables. Permamnent tables get created in the database you specify, temporary tables get 
created in TempDb and are automatically deleted, when they are no longer used
there are two types of it.
1. Local Temporary Tables
2. Global Temporary Tables

To create temp table
CMD: create table #emps(name int)

a local temp table is only accessible in its own tab. if you open a new tab and run query that table will not be available.
if you close the current tab where the temp table was created it will be dropped automatically.

CMD: Select name from tempdb..sysobjects where name Like '#emps'.

 here we need to use LIKE because temptable when gets created SQL server adds some random character to the table name.
 
 Global Temporary Tables
 CMD: create table ##emps(name int)
 
 they are accesible from multuiple tabs/connection. they only get destroyed when the last connection is closed. 
 
 Indexes:
 They are used to find data from tables quickly. they are created for tables and views.
 
 CMD: create INDEX IX_PERSON on tblPerson (salary asc)
 
	To know all the index in a table
	CMD:sp_helpindex tblPerson

	Drop Indexes
	CMD: drop index tblPerson.IX_PERSON 


Indees are of many types
	- Non Clustered and Clustered
	
	PK creatin in a table automatically creates a index (clustered) SQL Servcer uses this index to enfoprce unique constrsaint on primary key
	no matter hoe you store the data the dtata always gets sorted as per the clustered index in this case primary key
	thast is way if you input id = 3 and then input id = 1. when you do select * ======== id = 1 will come first
	one table can haver onbly 1 clustered index,but that clustered index can be includinbg multiple columns
	those are called "composite clustered index"
	CMD:Create clustered index IX_TBlEmp on tblEmp(Gender Desc, Salary ASC)
       now if gender is same then salary will be in ascending order
	   
	in no clustered index a separate table is created and then the as per the row address different rows in original table is accessed like index in a book

CMD: Create NonClustered Index IX_TblEmployee ON tblEmployee(Name)
Non clustered indexes are stored separately so extra disk space is required.
By default PK creaetes an unique clustered Index on the table.
PK uses unique index behind the scene to enforce uniqueness.
Advantage of Index:
Always remember: PK are nothning but Clustered index, that is why select * always gives the data in sorted format.
fast updation deletion seletion
Disadvantage of Index (non clustered):
Additional Disk Storage
Covering Query: Suppsoe we created a non clustered index on columns firstname then if out query just want to fetch the
first name in that case we alreadyh have that in our CLustered Look up table. so qurery dont need to go to the main table. so more fast
A clustered index is alwaYS A covering query: Reason being it is done on the same table. clustered index does not have a separate table.

View is more like a virtual table
CMD: Create View vwMyView as Select id,name,deptname from tblEmp join tblDept ON tblEmp.id = tblDept.Id;

sp_helptext vwMyView;

IMP: views are just stored SQL queries. 
updating views will update the base tables 
iNDEXED Views:
Indexed-View : When we create a Clustered Index on a view then views gets material;ized thus can keep data too.

Limitations of a View: You cannot pass parameter to a view. If one needs to pass parameter then either call the view and use wqhere cvlause if not then use Fucntions

Views cannot be created for a temporary tables.

Triggers are of 3 types:
1. DML
2. DDL
3. LogOn

DML trigger asre affcted by insert, update and delete.

DML Trigger are again of two types:
a. After triggers
b. Instead of triggers

a. After Insert triggers: it is triggered when insert statement is run. 

Create trigger tr_Emps_Audit
On Emps
 For Insert
 As
 Begin
 --Declare @Id int
 Select *  from inserted
 End
 
 Now "inserted" depicts the row tha tis getting inserted. So basially this above command will output the inserted row.
 
  Insert into Emps values (3,'Tanuj',4500,'M', 2);
  after running this above command we will again see the same as output. as this will asct as "Inserted".
  
  
  Example:
  CMD: create trigger tr_Emps_Audit
On Emps
 For Insert
 As
 Begin
 Declare @Id int
Select  @Id = Id  from inserted
insert into Audit Values(1, 'Id inserted is ' + cast(@Id as nvarchar(5)));

 End
 
 DELETED:
 CMD:  create trigger tr_Emps_Audit_del
On Emps
 For Delete
 As
 Begin
 Declare @Id int
Select  @Id = Id  from deleted
insert into Audit Values(1, 'Id deleted is ' + cast(@Id as nvarchar(5)));
 End
 
 Update trigggers
 
 Create trigger tr_tblEMps_Update
on Emps
 For Update
 As
 Begin
 select * from deleted // it holds the OLD value that is getting updated
 Select * from inserted  // It holds the NEW valuie that is getting updated to.
 End
 
 update  Emps set id = 4 where id = 5;
 
 deleted will contain data related to id = 5
 updated will contain data related to id = 4
 
 Normalization:
 is the process of minimizing data redundaNCY which in turns provides data consistency
 Problems with Data Redundancy:
 a. Disk Space Wastage
 b. Data Inconsistency
 c. DML queries can be slow
 
1 NF:
 Data should be automic in each column we should not have comma separated values.
 Identify each record using uniquely via PK
2 NF:Move redundant data to separa to table and join with FK Relationship 
3 NF: All the columns must be dependent fully dependent on PK. suppose we have a salary column and annual salary column 
then annual salary isa dependent on salary which is not a PK. So we need to remove annual salary columns.   

Derived Tables:
Select DeptName, TotalEmployees
from
{
Select DeptName, DepartmentId, COUNT(*) as TotalEmployees
from tblEmployee
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptIdgroup by DeptName, DepartmentId
}
as EmployeeCount
where TotalEmployees > = 2










  

	
	
	






